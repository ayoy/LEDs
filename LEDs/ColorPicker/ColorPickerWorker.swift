//
//  ColorPickerWorker.swift
//  
//
//  Created by Dominik Kapusta on 14/10/2017.
//  Copyright (c) 2017 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

class ColorPickerWorker: NSObject, URLSessionDelegate
{
    private let instanceMutex = PThreadMutex(type: .recursive)
    private var _isTaskInProgress: Bool = false
    var isTaskInProgress: Bool {
        get {
            var value: Bool = false
            instanceMutex.sync {
                value = _isTaskInProgress
            }
            return value
        }
        set {
            instanceMutex.sync {
                _isTaskInProgress = newValue
            }
        }
    }

    func doSomeWork()
    {
    }
    
    private func queryString(with color: UIColor) -> String {
        var r: CGFloat = 0, g: CGFloat = 0, b: CGFloat = 0
        color.getRed(&r, green: &g, blue: &b, alpha: nil)
        
        let redString = String(Int(r*255))
            .addingPercentEncoding(withAllowedCharacters: .alphanumerics)!
        let greenString = String(Int(g*255))
            .addingPercentEncoding(withAllowedCharacters: .alphanumerics)!
        let blueString = String(Int(b*255))
            .addingPercentEncoding(withAllowedCharacters: .alphanumerics)!

        return "?r=\(redString)&g=\(greenString)&b=\(blueString)"
        
    }
    
    func getColor(_ completionHandler: @escaping ([String:Int]) -> Void) {

        if !isTaskInProgress {
            let url = URL(string: "https://rpi.local/get_color")!
            let task = urlSession.dataTask(with: url) { (data: Data?, response: URLResponse?, error: Error?) in
                if let error = error {
                    print(error)
                    DispatchQueue.main.async {
                        completionHandler([:])
                    }
                } else if let data = data {
                    do {
                        let json = try JSONSerialization.jsonObject(with: data, options: [])
                        DispatchQueue.main.async {
                            completionHandler(json as? [String:Int] ?? [:])
                        }
                    } catch (let error) {
                        print("JSON deserialization error: \(error)")
                        DispatchQueue.main.async {
                            completionHandler([:])
                        }
                    }
                }
                self.isTaskInProgress = false
            }
            task.resume()
            isTaskInProgress = true
        }
    }
    
    func setColor(_ color: UIColor) {
        
        if !isTaskInProgress {
            let query = queryString(with: color)
            
            let url = URL(string: "https://rpi.local/color\(query)")!
            let task = urlSession.dataTask(with: url) { (data: Data?, response: URLResponse?, error: Error?) in
                if let error = error {
                    print(error)
                }
                self.isTaskInProgress = false
            }
            task.resume()
            isTaskInProgress = true
        }

    }
    
    private lazy var urlSession: URLSession = {
        let configuration = URLSessionConfiguration.default
        return URLSession(configuration: configuration,
                          delegate: self,
                          delegateQueue: workerQueue)
    }()
    
    private let workerQueue = OperationQueue()
    
    func urlSession(_ session: URLSession,
                    didReceive challenge: URLAuthenticationChallenge,
                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
    {
        if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
            if challenge.protectionSpace.host == "rpi.local" {
                
                if let certFile = Bundle.main.path(forResource: "cert", ofType: "der"),
                    let data = try? Data(contentsOf: URL(fileURLWithPath: certFile)),
                    let cert = SecCertificateCreateWithData(nil, data as CFData),
                    let trust = challenge.protectionSpace.serverTrust
                {
                    SecTrustSetAnchorCertificates(trust, [cert] as CFArray)
                    completionHandler(.useCredential, URLCredential(trust: trust))
                } else {
                    completionHandler(.cancelAuthenticationChallenge, nil)
                }
            } else {
                completionHandler(.performDefaultHandling, nil)
            }
        }
    }

}
